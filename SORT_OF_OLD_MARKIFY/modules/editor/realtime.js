modules["editor/realtime"] = class {
  icons = {
    highlighter: `<svg width="40" height="40" viewBox="0 0 45 45" fill="none" xmlns="http://www.w3.org/2000/svg"> <g filter="url(#filter0_d_254_26)"> <path d="M16.3781 22.4071L15.4384 22.0651L15.0964 23.0048L12.0871 31.2728C11.3315 33.3487 12.4019 35.644 14.4778 36.3996L19.1875 38.1138C21.2634 38.8694 23.5588 37.799 24.3144 35.7231L27.3237 27.4551L27.6657 26.5155L26.726 26.1734L16.3781 22.4071Z" toolcoloropacity stroke="white" stroke-width="2"/> <path d="M24.3631 32.6623L25.3028 33.0044L25.6448 32.0647L31.8824 14.927C32.6379 12.8511 31.5676 10.5557 29.4917 9.80018L24.7819 8.08596C22.706 7.33039 20.4106 8.40074 19.655 10.4767L13.4175 27.6143L13.0754 28.554L14.0151 28.896L24.3631 32.6623Z" fill="MEMBER_COLOR_REPLACE" stroke="white" stroke-width="2"/> </g> <defs> <filter id="filter0_d_254_26" x="6.84473" y="2.84375" width="30.2803" height="40.5127" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"> <feFlood flood-opacity="0" result="BackgroundImageFix"/> <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/> <feOffset/> <feGaussianBlur stdDeviation="2"/> <feComposite in2="hardAlpha" operator="out"/> <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/> <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_254_26"/> <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_254_26" result="shape"/> </filter> </defs> </svg>`,
    pen: `<svg width="40" height="40" viewBox="0 0 45 45" fill="none" xmlns="http://www.w3.org/2000/svg"> <g filter="url(#filter0_d_257_2)"> <path d="M18.6315 19.2186L17.6918 18.8766L17.3498 19.8163L14.5155 27.6032C13.5713 30.1976 13.87 33.0818 15.3259 35.4275L15.6683 35.9791C16.1549 36.7631 17.1147 37.1125 17.9914 36.8247L18.6082 36.6222C21.2313 35.7611 23.3141 33.7437 24.2584 31.1493L27.0926 23.3624L27.4346 22.4227L26.4949 22.0807L18.6315 19.2186Z" toolcoloropacity stroke="white" stroke-width="2"/> <path d="M23.5076 30.2844L24.4473 30.6264L24.7893 29.6867L30.0855 15.1356C31.0647 12.4452 29.6775 9.47036 26.9871 8.49113C24.2967 7.51191 21.3219 8.89909 20.3427 11.5895L15.0465 26.1406L14.7045 27.0803L15.6441 27.4224L23.5076 30.2844Z" fill="MEMBER_COLOR_REPLACE" stroke="white" stroke-width="2"/> </g> <defs> <filter id="filter0_d_257_2" x="8.97266" y="3.17676" width="26.4268" height="38.748" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"> <feFlood flood-opacity="0" result="BackgroundImageFix"/> <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/> <feOffset/> <feGaussianBlur stdDeviation="2"/> <feComposite in2="hardAlpha" operator="out"/> <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/> <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_257_2"/> <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_257_2" result="shape"/> </filter> </defs> </svg>`,
    eraser: `<svg width="40" height="40" viewBox="0 0 45 45" fill="none" xmlns="http://www.w3.org/2000/svg"> <g filter="url(#filter0_d_257_10)"> <path d="M36 19V27C36 29.2091 34.2091 31 32 31L12 31C9.79086 31 8 29.2091 8 27V19C8 16.7909 9.79086 15 12 15L32 15C34.2091 15 36 16.7909 36 19Z" fill="white" stroke="white" stroke-width="2"/> <path d="M36 19V27C36 29.2091 34.2091 31 32 31L12 31C9.79086 31 8 29.2091 8 27V19C8 16.7909 9.79086 15 12 15L32 15C34.2091 15 36 16.7909 36 19Z" fill="MEMBER_COLOR_REPLACE" stroke="white" stroke-width="2"/> <rect x="20.5557" y="16" width="2.88889" height="14" fill="white"/> </g> <defs> <filter id="filter0_d_257_10" x="3" y="10" width="38" height="26" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"> <feFlood flood-opacity="0" result="BackgroundImageFix"/> <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/> <feOffset/> <feGaussianBlur stdDeviation="2"/> <feComposite in2="hardAlpha" operator="out"/> <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/> <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_257_10"/> <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_257_10" result="shape"/> </filter> </defs> </svg>`
  };
  css = {
    ".eCursor": `--backgroundColor: var(--themeColor); --textColor: var(--themeColor); --borderColor: #fff; position: absolute; display: flex; z-index: 20; opacity: 0; align-items: center; transition: .25s; pointer-events: all; transform-origin: var(--origin)`,
    ".eCursor[pressed]": `--backgroundColor: #fff; --borderColor: var(--themeColor); color: var(--textColor) !important; transform: scale(.9)`,
    ".eCursor .pointer": `width: 20px; height: 20px; background: var(--backgroundColor); border: solid 3px var(--borderColor); overflow: hidden; border-radius: 8px 14px 14px 14px; box-shadow: 0 0 6px rgb(0 0 0 / 50%); transition: all .3s, color 0s`,
    ".eCursor .pointer[none]": `border-radius: 14px; opacity: 0; width: 0px`,
    ".eCursor [name]": `box-sizing: border-box; display: flex; width: fit-content; height: 100%; padding: 0px 6px; border-radius: 14px; overflow: hidden; opacity: 0; font-size: 14px; font-weight: 700; white-space: nowrap; align-items: center`,
    ".eCursor:not([anonymous]):hover [color]": `width: var(--fullyExtended)`,
    ".eCursor:not([anonymous]):hover [name]": `width: unset; opacity: 1`,
    ".eCursor:not([anonymous]):hover .pointer[none]": `opacity: 1`,
    ".eCursor:not([anonymous])[extend] [color]": `width: var(--fullyExtended)`,
    ".eCursor:not([anonymous])[extend] [name]": `width: unset; opacity: 1`,
    ".eCursor:not([anonymous])[extend] .pointer[none]": `opacity: 1`,
    ".eCursor[anonymous]": `--themeColor: var(--theme) !important; pointer-events: none !important`,
    ".eCursor[anonymous] [name]": `opacity: 0`,

    ".eSelection": `opacity: 0; z-index: 10; transition: .3s`,
    ".eSelection div": `position: absolute; background: var(--themeColor); opacity: .4; border-radius: 4px`,

    ".eCollabSelect": `position: absolute; left: 0px; top: 0px; border: solid 3px var(--themeColor); opacity: 0; z-index: 9; border-radius: 9px; opacity .15s; pointer-events: none`,
    ".eCollabSelect[anonymous]": `--themeColor: var(--theme) !important`
  };
  js = async function (editor, page) {
    editor.realtime.module = this;

    page.querySelector(".eMembers").removeAttribute("disabled");
    page.querySelector(".eShare").removeAttribute("disabled");

    let endSession = page.querySelector(".eEndSession");
    endSession.removeAttribute("disabled");
    endSession.addEventListener("click", async () => {
      endSession.setAttribute("disabled", "");
      let [code] = await sendRequest("DELETE", "lessons/members/reset", null, { session: editor.session });
      if (code == 200) {
        let members = Object.keys(editor.members);
        for (let i = 0; i < members.length; i++) {
          let member = editor.members[members[i]];
          if (member.access == 1) {
            member.access = 0;
            this.removeRealtime(member._id);
          }
        }
        editor.editorCount = 0;
        editor.checkEditorCount();
      }
      endSession.removeAttribute("disabled");
    });

    let alert = await loadModule("alert");

    editor.codeTextButton.setAttribute("dropdown", "dropdowns/editor/share/pin");

    // Update connectivity:
    let statusIcon = page.querySelector(".eConnection");
    this.connectUpdate = (updateShort) => {
      //object-position: -60px -4px;
      let imgPos = 0;
      let status = "";
      switch (editor.realtime.strength) {
        case 3: // Full Connection:
          imgPos = -60;
          status = "Strong Connection | All features seamlessly synced to the cloud.";
          break;
        case 2: // Weak Connection
          imgPos = -30;
          status = "Weak Connection | Cloud-saved annotations, limited real-time features.";
          break;
        case 1: // No Connection
          imgPos = 0;
          status = "No Connection | Annotations stored on-device, synced to cloud upon reconnecting.";
      }
      statusIcon.style.objectPosition = imgPos + "px -4px";
      statusIcon.title = status;
      statusIcon.removeAttribute("disabled");

      if (updateShort != false) {
        this.setShortSub(editor.visibleChunks);
      }

      let zCursorAction = fixed.querySelector('.eZoomAction[option="cursors"]');
      let zCursorNameAction = fixed.querySelector('.eZoomAction[option="cursornames"]');
      if (zCursorAction) {
        if (editor.realtime.strength < 3) {
          zCursorAction.style.opacity = 0.5;
          zCursorAction.title = "Cursors disabled due to weak connection.";
          zCursorNameAction.style.opacity = 0.5;
        } else {
          zCursorAction.style.opacity = 1;
          zCursorAction.title = "Display the cursors of other editors.";
          zCursorNameAction.style.opacity = 1;
        }
      }
    }

    // PING / PONG for measuring internet speed:
    let pingFilter = { c: "short_" + editor.id, o: editor.sessionID, t: editor.sessionToken };
    let awaiting = {};
    let timeoutTime = 500; // ms
    subscribe(pingFilter, (pingID) => {
      if (getEpoch() - pingID < timeoutTime) {
        awaiting[pingID] = "";
      }
    });
    let ping = (attempt) => {
      if (editor.active == false) {
        return;
      }
      attempt = attempt ?? 1;
      let pingID = getEpoch();
      setTimeout(() => {
        if (awaiting[pingID] == "") {
          delete awaiting[pingID];
          // STRONG INTERNET
          if (editor.realtime.strength != 3) {
            if (attempt < 3) {
              // Try 2 more times to make sure:
              ping(attempt + 1);
            } else {
              // Enable the stuff:
              editor.realtime.strength = 3;
              editor.sendPing();
              this.connectUpdate();
              alert.open("info", "<b>Connection Restored</b>A strong connection has been established, all features enabled.");
            }
          }
        } else {
          // WEAK INTERNET
          if (editor.realtime.strength != 2) {
            if (attempt < 3) {
              // Try 2 more times to make sure:
              ping(attempt + 1);
            } else {
              // Disable the stuff:
              editor.realtime.strength = 2;
              this.exitObserve();
              editor.sendPing();
              this.connectUpdate();
              this.removeRealtime();
              alert.open("info", "<b>Weak Connection</b>While you're still connected, real-time collaboration is disabled to save bandwidth.");
              if (editor.realtime.observed == true) {
                editor.realtime.observed = null;
              }
            }
          }
        }
      }, timeoutTime);
      socket.publish(pingFilter, pingID, { publishToSelf: true });
    }
    addTempListener({
      type: "interval", interval: setInterval(async () => {
        if (connected) {
          ping();
        }
      }, 45000)
    }); // PING every 45 seconds

    // CURSORS
    let realtimeHolder = page.querySelector(".eRealtime");
    let pageHolder = page.querySelector(".ePageHolder");
    let lastCursorPublish = 0;
    let lastObservePublish = 0;
    let lastCursorContent = "";
    let lastObserveContent = "";
    let lastCursorChunk;

    let utils = editor.utils;
    
    let mouseX = 0;
    let mouseY = 0;
    let endSyncTimeout;
    let endSyncObserveTimeout;
    this.publishShort = async (event, type, ignoreSame) => {
      type = type ?? "cursor";
      if (event != null) {
        mouseX = clientPosition(event, "x");
        mouseY = clientPosition(event, "y");
      }
      if (editor.memberCount < 2) { // No one to send cursor events too!
        return;
      }
      if (editor.realtime.strength < 3) { // If weak don't send!
        return;
      }
      if (editor.getSelf().access < 1 && editor.realtime.observed != true) { // Not an editor!
        return;
      }
      if (type == "cursor") {
        /* // Disabled as others should still see your cursor!
        if (editor.options.cursors == false) {
          return;
        }
        */
        clearTimeout(endSyncTimeout);
        if (lastCursorPublish < getEpoch() - 80 || ignoreSame == true) { // One event every 80 ms
          let standardFilter = { c: "short_" + editor.id };
          if (editor.realtime.observed && editor.getSelf().access < 1) {
            standardFilter.o = editor.sessionID;
          }
          let filter = { ...standardFilter };
  
          // Figure out where the cursor is:
          let sendX = mouseX;
          let sendY = mouseY;
          let pageRect = pageHolder.getBoundingClientRect();
          sendX -= pageRect.left;
          sendY -= pageRect.top;
          sendX /= editor.zoom;
          sendY /= editor.zoom;
          if (editor.visibleChunks) {
            filter.p = editor.pointInChunk(sendX, sendY);
          }
  
          if (filter.p != (lastCursorChunk ?? filter.p)) {
            socket.publish({ ...standardFilter, p: lastCursorChunk }, [ editor.sessionID, filter.p ]); // When leaving a chunk, tell those looking!
          }
  
          let scaleZoom = 1 / editor.zoom;
  
          // [ memberID, tool, time, mouseX, mouseY, extra (anno) ]
          let pubData = [ editor.sessionID, editor.realtime.tool, 0, Math.floor(sendX), Math.floor(sendY)];

          let addTextSelect = [];
          if (window.getSelection != null) {
            let select = window.getSelection();
            if (select.rangeCount > 0) {
              let range = select.getRangeAt(0);
              if (range.toString().length > 0 && range.endContainer.parentNode.getAttribute("role") == "presentation") {
                let selections = range.getClientRects();
                let alreadyInsert = {};
                for (let i = 0; i < Math.min(selections.length, 100); i++) {
                  let selRect = selections[i];
                  let checkInsert = (selRect.width * selRect.height) + selRect.left + selRect.top;
                  if (alreadyInsert[checkInsert] != null) {
                    continue;
                  }
                  let selX = selRect.x;
                  let selY = selRect.y;
                  let pageRect = pageHolder.getBoundingClientRect();
                  selX -= pageRect.left;
                  selY -= pageRect.top;
                  if (selRect.width > 0 && selRect.height > 0) {
                    alreadyInsert[checkInsert] = "";
                    // [ PAGE, WIDTH, HEIGHT, X, Y ]
                    addTextSelect.push([ Math.floor(selRect.width*scaleZoom), Math.floor(selRect.height*scaleZoom), Math.floor(selX * scaleZoom), Math.floor(selY * scaleZoom)]);
                  }
                }
              }
            }
          }
          let sendExtra = {};
          if (addTextSelect.length > 0) {
            sendExtra.selection = addTextSelect;
          }
          if (mouseDown()) {
            sendExtra.press = true;
          }
          let mergedSelect = { ...editor.selecting, ...editor.realtimeSelect };
          //console.log(JSON.stringify(editor.realtimeSelect))
          editor.realtimeSelect = {};
          if (Object.keys(mergedSelect).length > 0) {
            sendExtra.select = mergedSelect;
          }
          if (editor.realtime.passthrough != null) {
            sendExtra = { ...sendExtra, ...editor.realtime.passthrough };
          }
          if (ignoreSame == true) {
            sendExtra.force = true;
          }
          if (Object.keys(sendExtra).length > 0) {
            pubData[5] = sendExtra;
          }
          
          let updJSONContent = JSON.stringify([filter, pubData]);
          if (updJSONContent == lastCursorContent && ignoreSame != true) {
            return;
          }
          pubData[2] = getEpoch();
  
          // PUBLISH the event:
          socket.publish(filter, pubData);
          lastCursorPublish = getEpoch();
          lastCursorChunk = filter.p;
          lastCursorContent = updJSONContent;
        } else {
          endSyncTimeout = setTimeout(() => {
            this.publishShort(event, type);
          }, 100); // If after 100 MS, send the last event to ensure proper sync.
        }
      } else if (type == "observe") {
        clearTimeout(endSyncObserveTimeout);
        if (lastObservePublish < getEpoch() - 250) { // One event every 250 ms
          let filter = { c: "short_" + editor.id, o: editor.sessionID };

          let sendX = fixed.offsetWidth / 2;
          let sendY = fixed.offsetHeight / 2;
          let pageRect = pageHolder.getBoundingClientRect();
          sendX -= pageRect.left;
          sendY -= pageRect.top;
          sendX /= editor.zoom;
          sendY /= editor.zoom;

          // [ memberID, NULL, zoom, centerx, centery, time ]
          let pubData = [ editor.sessionID, null, Math.floor(editor.zoom * 100) / 100, Math.floor(sendX), Math.floor(sendY) ];

          let updJSONContent = JSON.stringify([filter, pubData]);
          if (updJSONContent == lastObserveContent && ignoreSame != true) {
            return;
          }
          pubData[5] = getEpoch();

          // PUBLISH the event:
          socket.publish(filter, pubData);
          lastObservePublish = getEpoch();
          lastObserveContent = updJSONContent;
        } else {
          endSyncObserveTimeout = setTimeout(() => {
            this.publishShort(event, type);
          }, 300); // If after 300 MS, send the last event to ensure proper sync.
        }
      }
    }
    editor.scrollEvent = () => {
      this.publishShort();
      if (editor.realtime.observed == true) {
        this.publishShort(null, "observe");
      }
    }
    tempListen(window, "resize", () => {
      if (editor.realtime.observed == true) {
        this.publishShort(null, "observe");
      }
    });


    page.addEventListener("mousemove", (event) => {
      if (editor.events.mouseMove != null) {
        editor.events.mouseMove(event);
      }
      this.publishShort(event);
    });
    page.addEventListener("mousedown", this.publishShort);
    page.addEventListener("mouseup", this.publishShort);

    page.addEventListener("touchmove", (event) => {
      if (editor.events.mouseMove != null) {
        editor.events.mouseMove(event);
      }
      this.exitObserve();
      this.publishShort(event);
    }, { passive: true });
    page.addEventListener("touchstart", this.publishShort, { passive: true });
    page.addEventListener("touchend", this.publishShort, { passive: true });

    tempListen(window, "wheel", () => {
      this.exitObserve();
    });

    this.adjustRealtimeHolder = () => { // Scale realtime elements when zoom or resize:
      let adjustElements = realtimeHolder.children; //querySelectorAll("[scale]");
      for (let i = 0; i < adjustElements.length; i++) {
        let element = adjustElements[i];
        if (element.hasAttribute("scale") == true) {
          element.setAttribute("notransition", "");
          if (element.hasAttribute("width")) {
            element.style.width = parseFloat(element.getAttribute("width")) * editor.zoom + "px";
          }
          if (element.hasAttribute("height")) {
            element.style.height = parseFloat(element.getAttribute("height")) * editor.zoom + "px";
          }
          /*let pageElem = pageHolder;
          if (element.hasAttribute("page")) {
            pageElem = pageHolder.children[parseInt(element.getAttribute("page")) - 1] ?? pageElem;
          }*/
          let pageRect = pageHolder.getBoundingClientRect();
          if (element.hasAttribute("x") && element.hasAttribute("y")) {
            let x = parseFloat(element.getAttribute("x")) * editor.zoom;
            let y = parseFloat(element.getAttribute("y")) * editor.zoom;
            element.style.transform = "translate(" + (x + pageRect.left + (parseInt(element.getAttribute("offsetx") ?? "0")) + window.scrollX) + "px," + (y + pageRect.top + (parseInt(element.getAttribute("offsety") ?? "0")) + window.scrollY) + "px)";
          }
          element.offsetHeight;
          element.removeAttribute("notransition");
        }
        if (editor.lesson.settings.anonymousMode != true) {
          element.removeAttribute("anonymous");
        } else {
          element.setAttribute("anonymous", "");
        }
      }
    }

    let observeHolder = editor.page.querySelector(".eObserveHolder");
    let observeTag = observeHolder.querySelector(".eObserve");
    let observeBorder = editor.page.querySelector(".eObserveBorder");
    this.enableObserve = async (member) => {
      (await loadModule("alert")).close(editor.realtime.observeLoading);
      editor.realtime.observeLoading = null;

      clearTimeout(editor.realtime.observeTimeout);
      
      observeTag.style.background = member.color;
      observeTag.style.color = editor.textColorBackground(member.color);
      observeTag.querySelector("b").textContent = member.name;
      observeHolder.style.display = "flex";
      observeBorder.style.border = "solid 3px " + member.color;

      editor.updateInterface(true);
    }
    this.exitObserve = async () => {
      let prevObservID = editor.realtime.observing;
      editor.realtime.observing = null;
      
      (await loadModule("alert")).close(editor.realtime.observeLoading);
      clearTimeout(editor.realtime.observeTimeout);

      if (prevObservID == null) {
        return;
      }

      observeHolder.style.display = "none";
      observeBorder.style.border = "unset";
      cancelAnimationFrame(animationFrameId);
      editor.updateInterface(true);

      if (editor.lastZoom != null) {
        editor.setZoom(editor.lastZoom, true);
        editor.lastZoom = null;
      }

      let member = editor.members[prevObservID];
      if (member == null) {
        return;
      }
      if (member.access < 1) {
        this.removeRealtime(member._id);
      }
      sendRequest("DELETE", "lessons/members/observe/exit?member=" + member._id, null, { session: editor.session });
      editor.realtime.module.observeButtonUpdate();
    }
    observeTag.querySelector("button").addEventListener("click", () => {
      this.exitObserve();
    });

    this.removeRealtime = (memberID) => {
      let remMemberElem = realtimeHolder.children;
      if (memberID != null) {
        remMemberElem = [ ...realtimeHolder.querySelectorAll('[member="' + memberID + '"]'), ...editor.page.querySelectorAll('.eAnnotation[member="' + memberID + '"]') ];
      }
      for (let i = 0; i < remMemberElem.length; i++) {
        let elem = remMemberElem[i];
        (async function () {
          elem.style.opacity = 0;
          await sleep(300);
          elem.remove();
        })();
      }
      let member = editor.members[memberID];
      if (member == null) {
        return;
      }
      if (member.activeAnno != null) {
        member.activeAnno.remove();
        member.activeAnno = null;
      }
    }
    this.shortSub = null;
    let targetScrollPositionX = 0;
    let targetScrollPositionY = 0;
    let animationFrameId;
    let tempListenAnimation = { type: "animation" };
    addTempListener(tempListenAnimation);
    let smoothScroll = () => {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
      }

      const distanceX = (targetScrollPositionX - window.scrollX) / 10; // Divide the distance into steps
      const distanceY = (targetScrollPositionY - window.scrollY) / 10; // Divide the distance into steps
      
      let changeX = Math.min(distanceX, 50);
      if (distanceX < 0) {
        changeX = Math.max(distanceX, -50);
      }
      let changeY = Math.min(distanceY, 50);
      if (distanceY < 0) {
        changeY = Math.max(distanceY, -50);
      }
      if (Math.abs(distanceY) > 1 || Math.abs(distanceX) > 1) {
        window.scrollTo({ left: window.scrollX + changeX, top: window.scrollY + changeY });
        animationFrameId = requestAnimationFrame(smoothScroll);
        tempListenAnimation.frame = animationFrameId;
      }
    }
    let startScroll = (targetX, targetY) => {
      targetScrollPositionX = targetX;
      targetScrollPositionY = targetY;
      smoothScroll();
    }
    let transformTimeout;
    this.setShortSub = (chunks) => {
      if (editor.realtime.strength < 3 || editor.options.cursors == false) {
        chunks = null;
      }
      let filter = { c: "short_" + editor.id, p: chunks };
      if (editor.realtime.observing != null) {
        filter.o = editor.realtime.observing;
      }
      if (this.shortSub) {
        this.shortSub.edit(filter);
      } else {
        if (chunks == null) {
          return;
        }
        this.shortSub = subscribe(filter, async (data) => {
          //console.log(data);
          let member = editor.members[data[0]];
          if (member == null) {
            return;
          }
          if (data[1] != null) { // CURSOR
            if (editor.options.cursors == false) {
              return;
            }
            let [ memberID, tool, time, x, y, extra ] = data;
            let forced = extra != null && extra.force == true;
            if (member.lastShort > time && forced == false) {
              return;
            }
            member.lastShort = time;
            clearInterval(member.interval);
            member.interval = setInterval(() => {
              this.removeRealtime(memberID);
            }, 120000); // Remove realtime member elements if inactive for 2 minutes
            let cursorHolder = realtimeHolder.querySelector('.eCursor[member="' + memberID + '"]');
            if (cursorHolder == null) {
              realtimeHolder.insertAdjacentHTML("beforeend", `<div class="eCursor" member="${memberID}" scale></div>`);
              cursorHolder = realtimeHolder.querySelector('.eCursor[member="' + memberID + '"]');
              cursorHolder.offsetHeight;
              cursorHolder.style.opacity = 1;
            }
            if (editor.lesson.settings.anonymousMode != true) {
              cursorHolder.removeAttribute("anonymous");
            } else {
              cursorHolder.setAttribute("anonymous", "");
            }
            let updateCursorProps = async () => {
              let userSelection = (extra ?? {}).select ?? {};
              let selectKeys = Object.keys(userSelection);
              let allSelections = editor.page.querySelectorAll('.eCollabSelect[member="' + memberID + '"], .eAnnotation[member="' + memberID + '"]');
              for (let i = 0; i < allSelections.length; i++) {
                let select = allSelections[i];
                if (selectKeys.includes(select.getAttribute("anno")) == false) {
                  (async function () {
                    select.setAttribute("old", "");
                    select.style.opacity = 0;
                    await sleep(150);
                    select.remove();
                  })();
                }
                if (editor.lesson.settings.anonymousMode != true) {
                  select.removeAttribute("anonymous");
                } else {
                  select.setAttribute("anonymous", "");
                }
              }
              if (extra != null) {
                if (extra.c != null) {
                  let setColor = cursorHolder.querySelector("[toolcoloropacity]");
                  if (setColor != null) {
                    setColor.setAttribute("fill", "#" + extra.c ?? "000");
                    setColor.setAttribute("fill-opacity", (extra.o ?? 100) / 100);
                  }
                }
                if (selectKeys.length > 0) {
                  let userSelecting = false;
                  let refreshSelecting = false;
                  let changes = false;
                  let hasCursorAnno = false;
                  let pageRect = pageHolder.getBoundingClientRect();
                  for (let i = 0; i < selectKeys.length; i++) {
                    let annoID = selectKeys[i];
                    let anno = extra.select[annoID] ?? {};
                    let merge;
                    let annoElem;
                    let original;
                    if (annoID == "cursor") {
                      // Just a temporary prop, no saving:
                      let prevElem = editor.page.querySelector('.eAnnotation[member="' + memberID + '"]');
                      if (prevElem != null && prevElem.getAttribute("type") != anno.f) {
                        prevElem.remove();
                        prevElem = null;
                      }
                      [merge, annoElem] = await utils.render({ ...anno, _id: memberID + "_cursor" }, prevElem);
                      annoElem.setAttribute("member", memberID);
                      annoElem.setAttribute("anno", "cursor");
                      annoElem.setAttribute("type", anno.f);
                      annoElem.style.opacity = .7;
                      hasCursorAnno = true;
                      member.cursorRender = merge;
                    } else {
                      original = editor.annotations[annoID];
                      if (original != null && original.pointer != null) {
                        annoID = original.pointer;
                        original = editor.annotations[annoID];
                      }
                      anno._id = annoID;
                      let isNewAnno = annoID.startsWith("pending_") == true;
                      if (original == null && isNewAnno == true) {
                        editor.annotations[annoID] = {};
                        original = editor.annotations[annoID];
                      }
                      original = original ?? {};
                      let originalRender = original.render ?? {};
                      if (editor.lesson.settings.editOthersWork != true && (originalRender.a ?? originalRender.m) != null && [originalRender.a, originalRender.m].includes(member.modify) == false && member.access < 4) { // Can't edit another member's work:
                        delete userSelection[annoID];
                        continue;
                      }
                      let setRender = { ...originalRender, ...anno };
                      if (setRender._id == null || setRender.p == null || setRender.s == null) {
                        delete userSelection[annoID];
                        continue;
                      } else if (setRender.remove == true) {
                        delete userSelection[annoID];
                      }
                      if (anno.lock == false) {
                        if ([originalRender.a, originalRender.m].includes(member.modify) == false && member.access < 4) {
                          anno.lock = null;
                        }
                      }
                      /*if (originalRender.lock == true && anno.lock != false) { // Can't edit another member's work:
                        continue;
                      }*/
                      original.revert = original.revert ?? JSON.parse(JSON.stringify(originalRender));
                      // If the user is also selecting, we must update their fields accordingly:
                      /*
                      if (selecting != null) {
                        let annoKeys = Object.keys(anno);
                        for (let f = 0; f < annoKeys.length; f++) {
                          if (selecting[annoKeys[f]] != null) {
                            selecting[annoKeys[f]] = anno[annoKeys[f]];
                          }
                        }
                      }
                      */
                      if (originalRender.lock != true || anno.lock == false) { // Can't edit another member's work:
                        if (anno.remove == true && editor.selecting[annoID] != null) {
                          delete editor.selecting[annoID];
                          if (editor.toolbar != null) {
                            editor.toolbar.cursor.updateBox();
                          }
                        }
                        if (anno.done != true && forced != true) {
                          original.render = setRender;
                        } else {
                          original.render = setRender;
                          delete original.render.done;
                          await utils.saveEdit(anno, null, time);
                        }
                        if (Object.keys({ ...anno, done: "" }).length > 2) {
                          if (isNewAnno == false) {
                            original.render.m = member.modify;
                          } else {
                            original.render.a = member.modify;
                          }
                          changes = true;
                        }
                        original.render.sync = time;
                        utils.enableTimeout(annoID, original, null, true);
                      }
                    }

                    let selection;
                    //if (original.render._id.startsWith("pending_") == false) {
                    if ((anno.f == null || anno.sync != null || annoID == "cursor") && userSelection[annoID] != null) {
                      selection = realtimeHolder.querySelector('.eCollabSelect[member="' + memberID + '"][anno="' + annoID + '"]:not([old])');
                      if (selection == null) {
                        realtimeHolder.insertAdjacentHTML("beforeend", `<div class="eCollabSelect" member="${memberID}" new></div>`);
                        selection = realtimeHolder.querySelector('.eCollabSelect[member="' + memberID + '"][new]');
                        selection.removeAttribute("new");
                        selection.setAttribute("anno", annoID);
                        selection.style.setProperty("--themeColor", member.color);
                        if (editor.lesson.settings.anonymousMode != true) {
                          selection.removeAttribute("anonymous");
                        } else {
                          selection.setAttribute("anonymous", "");
                        }
                        selection.offsetHeight;
                      }
                    }

                    if (annoID != "cursor") {
                      if (editor.selecting[annoID] == null) {
                        merge = original.render;
                        if (selection != null) {
                          selection.removeAttribute("notransition");
                        }
                      } else {
                        merge = { ...original.render, ...(editor.selecting[annoID] ?? {}) };
                        userSelecting = true;
                      }
                      if (["text", "sticky"].includes(merge.f) == true && anno.d != null) {
                        let annoTx = editor.page.querySelector('.eAnnotation[anno="' + annoID + '"] div[contenteditable]');
                        if (annoTx != null) {
                          annoTx.removeAttribute("contenteditable");
                        }
                      }
                      await editor.annotationChunks(editor.annotations[annoID]);
                      [merge, annoElem] = await utils.render(merge);

                      if (selection != null && anno.remove == true && selection.hasAttribute("remove") == false) {
                        selection.setAttribute("remove", "");
                        (async function () {
                          selection.setAttribute("old", "");
                          selection.style.opacity = 0;
                          await sleep(150);
                          if (selection != null) {
                            selection.remove();
                          }
                        })();
                        selection = null;
                      }
                    }

                    if (selection != null) {
                      let border = 0;
                      let [width, height] = merge.s;
                      let [x, y] = editor.getAbsolutePosition(merge);
                      let rotate = merge.r ?? 0;
                      if (rotate > 180) {
                        rotate = -(360 - rotate);
                      }
                      if (width < 0) {
                        width = -width;
                        x -= width;
                      }
                      if (height < 0) {
                        height = -height;
                        y -= height;
                      }
                      let t = merge.t ?? 0;
                      if (merge.b == "none" && merge.d != "line") {
                        t = 0;
                      }
                      let boxWidth = ((width + t) * editor.zoom) - 3; // +0 for width, -3 for border
                      let boxHeight = ((height + t) * editor.zoom) - 3;
                      selection.style.width = boxWidth + "px";
                      selection.style.height = boxHeight + "px";
                      let halfT = t / 2;
                      //selection.style.left = pageRect.x + ((x + halfT) * editor.zoom) + window.scrollX - 1.5 + "px"; // -1.5 for border, -0 for width
                      //selection.style.top = pageRect.y + (((y + halfT) - border) * editor.zoom) + window.scrollY - 1.5 + "px";
                      selection.style.transform = "translate(" + (pageRect.x + ((x + halfT) * editor.zoom) + window.scrollX - 1.5) + "px," + (pageRect.y + (((y + halfT) - border) * editor.zoom) + window.scrollY - 1.5) + "px) rotate(" + rotate + "deg)";
                      selection.offsetHeight;
                      selection.style.transition = "all .25s, opacity .15s";
                      selection.style.opacity = 1;
                    }
                    if (annoElem != null && annoElem.querySelector(".eAnnotation[selected]") != null) {
                      refreshSelecting = true;
                    }
                  }
                  if (userSelecting == true && changes == true) { // Only refresh if user is selecting
                    if (editor.toolbar != null) {
                      editor.toolbar.cursor.redrawActionUI();
                    }
                  }
                  member.selecting = selectKeys;
                  if (userSelecting == true || refreshSelecting == true) {
                    editor.updateZoom(null, false);
                  }
                  if (member.cursorRender != null && hasCursorAnno == false) {
                    delete member.cursorRender;
                  }
                } else if (member.selecting != null) {
                  for (let i = 0; i < member.selecting.length; i++) {
                    let annoID = member.selecting[i];
                    if (editor.annotations[annoID] == null) { //annoID.startsWith("pending_") == true
                      utils.removeAnnotation(annoID, true);
                    }
                  }
                  delete member.selecting;
                }
                if (extra.u != null && extra.u._id != null) { // Update Annotation
                  let original = editor.annotations[extra.u._id];
                  if (original != null && original.pointer != null) {
                    extra.u._id = original.pointer;
                    original = editor.annotations[extra.u._id];
                  }
                  if (original == null && extra.u._id.startsWith("pending_") == true) {
                    editor.annotations[extra.u._id] = {};
                    original = editor.annotations[annextra.u._idoID];
                  }
                  original = original ?? {};
                  let originalRender = original.render ?? {};
                  if (editor.lesson.settings.editOthersWork == true || [originalRender.a, originalRender.m].includes(member.modify) == true || member.access > 3) { // Can edit another member's work:
                    await utils.saveEdit(extra.u);
                  } else {
                    let currentAnnoCheck = originalRender;
                    let checkedParents = [];
                    while (currentAnnoCheck.parent != null) {
                      let annoid = currentAnnoCheck.parent;
                      if (annoid == null || checkedParents.includes(annoid) == true) {
                        break;
                      }
                      checkedParents.push(annoid);
                      let annotation = editor.annotations[annoid];
                      if (annotation == null) {
                        break;
                      }
                      if (annotation.pointer != null) {
                        annoid = annotation.pointer;
                        annotation = this.annotations[annoid] ?? { render: {} };
                      }
                      currentAnnoCheck = annotation.render ?? {};
                      if ([originalRender.a, originalRender.m].includes(member.modify) == true) {
                        await utils.saveEdit(extra.u);
                        break;
                      }
                    }
                  }
                }
              }
              if (Object.keys(userSelection).length > 0 && editor.options.cursornames != false) {
                cursorHolder.setAttribute("extend", "");
              } else {
                cursorHolder.removeAttribute("extend");
              }
              if (extra != null && extra.press == true) {
                cursorHolder.setAttribute("pressed", "");
              } else {
                cursorHolder.removeAttribute("pressed");
              }
              //cursorHolder.style.left = member.x + (parseInt(cursorHolder.getAttribute("offsetx") ?? "0")) + window.scrollX + "px";
              //cursorHolder.style.top = member.y + (parseInt(cursorHolder.getAttribute("offsety") ?? "0")) + window.scrollY + "px";
              cursorHolder.style.transform = "translate(" + (member.x + (parseInt(cursorHolder.getAttribute("offsetx") ?? "0")) + window.scrollX) + "px," + (member.y + (parseInt(cursorHolder.getAttribute("offsety") ?? "0")) + window.scrollY) + "px)";
            }
            if (member.lastShort > time) {
              return;
            }
            // Set x and y:
            cursorHolder.setAttribute("x", x);
            cursorHolder.setAttribute("y", y);
            x *= editor.zoom;
            y *= editor.zoom;
            let pageRect = pageHolder.getBoundingClientRect();
            x += pageRect.left;
            y += pageRect.top;
            member.x = x;
            member.y = y;
            if (time == null) {
              // Must be for a page leave event:
              if (editor.visibleChunks.includes(tool)) {
                return;
              }
              this.removeRealtime(memberID);
              /*
              (async function () {
                cursorHolder.style.opacity = 0;
                await sleep(300);
                cursorHolder.remove();
              })();
              */
              return;
            } else {
              cursorHolder.style.opacity = 1;
            }
            if (parseInt(cursorHolder.getAttribute("mode") ?? -1) != tool) {
              cursorHolder.setAttribute("hidden", "");
              cursorHolder.style.transform = "translate(" + (member.x + (parseInt(cursorHolder.getAttribute("offsetx") ?? "0")) + window.scrollX) + "px," + (member.y + (parseInt(cursorHolder.getAttribute("offsety") ?? "0")) + window.scrollY) + "px) scale(0)";
              cursorHolder.setAttribute("mode", tool);
              clearTimeout(transformTimeout);
              transformTimeout = setTimeout(async () => {
                let html = "";
                let offsetx = 0;
                let offsety = 0;
                let origin = "top left";
                switch (tool) {
                  case 0: // Normal cursor:
                    html = `<div class="pointer" color><div name></div></div>`;
                    break;
                  case 1: // Highlighter 
                    html = `${this.icons.highlighter}<div class="pointer" color none><div name></div></div>`;
                    offsetx = -14;
                    offsety = -30;
                    origin = "bottom center";
                    break;
                  case 2: // Pen 
                    html = `${this.icons.pen}<div class="pointer" color none><div name></div></div>`;
                    offsetx = -14;
                    offsety = -30;
                    origin = "bottom center";
                    break;
                  case 3: // Eraser
                    html = `${this.icons.eraser}<div class="pointer" color none><div name></div></div>`;
                    offsetx = -20;
                    offsety = -20;
                    origin = "center center";
                }
                cursorHolder.innerHTML = html.replace(/MEMBER_COLOR_REPLACE/g, "var(--themeColor)");
                cursorHolder.setAttribute("offsetx", offsetx);
                cursorHolder.setAttribute("offsety", offsety);
                cursorHolder.style.setProperty("--origin", origin);
                cursorHolder.querySelector("[name]").textContent = member.name;
                let setTextColor = editor.textColorBackground(member.color);
                cursorHolder.style.color = setTextColor;
                if (setTextColor == "#000") {
                  cursorHolder.style.setProperty("--textColor", "#000");
                }
                cursorHolder.style.setProperty("--themeColor", member.color);
                let colorMain = cursorHolder.querySelector("[color]");
                colorMain.style.width = "fit-content";
                cursorHolder.style.setProperty("--fullyExtended", colorMain.clientWidth + "px");
                colorMain.style.removeProperty("width");
                updateCursorProps();
                cursorHolder.removeAttribute("hidden");
              }, 100);
            } else {
              updateCursorProps();
            }
            // Handle selection:
            let selectionHolder = realtimeHolder.querySelector('.eSelection[member="' + memberID + '"]:not([old])');
            if (extra && extra.selection) {
              let selection = extra.selection;
              if (selectionHolder == null) {
                realtimeHolder.insertAdjacentHTML("beforeend", `<div class="eSelection" member="${memberID}"></div>`);
                selectionHolder = realtimeHolder.querySelector('.eSelection[member="' + memberID + '"]:not([old])');
                selectionHolder.style.setProperty("--themeColor", member.color);
              }
              selectionHolder.innerHTML = "";
              for (let i = 0; i < Math.min(selection.length, 100); i++) {
                let selectData = selection[i];
                selectionHolder.insertAdjacentHTML("beforeend", `<div scale new></div>`);
                let select = selectionHolder.querySelector('.eSelection div[new]');
                select.removeAttribute("new");
                select.setAttribute("width", selectData[0]);
                select.setAttribute("height", selectData[1]);
                select.setAttribute("x", selectData[2]);
                select.setAttribute("y", selectData[3]);
                select.style.width = (selectData[0] * editor.zoom) + "px";
                select.style.height = (selectData[1] * editor.zoom) + "px";
                let selX = selectData[2] * editor.zoom;
                let selY = selectData[3] * editor.zoom;
                /*let pageElem = pageHolder;
                if (selectData[0] > 0) {
                  pageElem = pageHolder.children[selectData[0] - 1];
                  select.setAttribute("page", selectData[0]);
                }
                if (pageElem != null) {
                  let pageRect = pageElem.getBoundingClientRect();
                  select.style.left = (selX + pageRect.left) + window.scrollX + "px";
                  select.style.top = (selY + pageRect.top) + window.scrollY + "px";
                }*/
                let pageRect = pageHolder.getBoundingClientRect();
                selX += pageRect.left;
                selY += pageRect.top;
                //select.style.left = selX + window.scrollX + "px";
                //select.style.top = selY + window.scrollY + "px";
                select.style.transform = "translate(" + (selX + window.scrollX) + "px," + (selY + window.scrollY) + "px)";
              }
              selectionHolder.style.opacity = 1;
            } else if (selectionHolder != null) {
              (async function () {
                selectionHolder.setAttribute("old", "");
                selectionHolder.style.opacity = 0;
                await sleep(300);
                selectionHolder.remove();
              })();
            }
          } else if (data[3] != null) { // OBSERVE
            let [ memberID, _, zoom, scrollX, scrollY, time ] = data;
            if (memberID != editor.realtime.observing) {
              return;
            }
            if (member.lastObserveShort > time) {
              return;
            }
            if (editor.realtime.observeLoading != null) {
              editor.lastZoom = editor.zoom;
              this.enableObserve(member);
            }
            if (editor.zoom != zoom) {
              await editor.setZoom(zoom, true);
            }
            scrollX *= editor.zoom;
            scrollY *= editor.zoom;
            let pageRect = pageHolder.getBoundingClientRect();
            let setX = window.scrollX + pageRect.left;
            let setY = window.scrollY + pageRect.top;
            setX += scrollX;
            setY += scrollY;
            setX -= fixed.offsetWidth / 2;
            setY -= fixed.offsetHeight / 2;
            if (editor.realtime.observeLoading == null) {
              startScroll(setX, setY);
            } else {
              window.scrollTo({ left: setX, top: setY });
            }
            //smoothScrollTo(scrollX - (fixed.offsetWidth / 2), (scrollY - (fixed.offsetHeight / 2)) * scrollRate, 100);
            //window.scrollTo({ left: scrollX - (fixed.offsetWidth / 2), top: scrollY - (fixed.offsetHeight / 2), behavior: "smooth" });
          }
        });
      }
    }
    
    this.connectUpdate(editor.visibleChunks.length > 0);
  }
}

modules["dropdowns/editor/members"] = class {
  html = `
  <div class="eMemberHolder">
    <div class="eMemberSearchHolder">
      <img src="./images/editor/glass.svg">
      <input placeholder="Search..."></input>
    </div>
    <div class="eMemberMemberHolder">
      <div class="eMemberAccessHolder" access="5">
        <button class="eMemberAccessTitle"><div holder><div title>Owner</div><div count>0</div></div></button>
      </div>
      <div class="eMemberAccessHolder" access="1">
        <button class="eMemberAccessTitle"><div holder><div title>Editors</div><div count>0</div></div></button>
      </div>
      <div class="eMemberAccessHolder" access="0">
        <button class="eMemberAccessTitle"><div holder><div title>Viewers</div><div count>0</div></div></button>
      </div>
    </div>
  </div>
  `;
  css = {
    ".eMemberHolder": `width: 275px; max-width: 100%`,
    ".eMemberSearchHolder": `display: flex; padding: 8px 8px 4px 8px; align-items: center`,
    ".eMemberSearchHolder img": `width: 28px; height: 28px`,
    ".eMemberSearchHolder input": `max-width: calc(100% - 54px); width: 100%; padding: 4px 8px; margin-left: 6px; border: solid 2px var(--secondary); outline: unset; border-radius: 17px; font-family: var(--font); font-size: 16px; font-weight: 600`,
    ".eMemberSearchHolder input::placeholder": `color: var(--secondary)`,

    ".eMemberAccessHolder": `display: none; margin-bottom: 12px; background: var(--pageColor)`,
    ".eMemberAccessTitle": `position: sticky; display: flex; width: 100%; padding: 0; top: 0px; justify-content: center; align-items: center; background: rgba(var(--background), .7); backdrop-filter: blur(4px); z-index: 2; text-align: left; font-weight: 700; font-size: 18px`,
    ".eMemberAccessTitle div[holder]": `display: flex; width: 100%; padding: 4px 8px; top: 0px; justify-content: space-between; transition: .1s`,
    ".eMemberAccessTitle div[count]": `margin-left: 6px; font-weight: 500`,
    ".eMemberAccessTitle:hover div[holder]": `background: var(--hover)`,
    ".eMemberAccessTitle:active": `transform: scale(1) !important`,
    ".eMemberAccessTitle:active div[holder]": `background: var(--secondary); color: #fff !important`,
    ".eMemberAccessHolder[selected] .eMemberAccessTitle div[holder]": `background: var(--secondary); color: #fff`,

    ".eMemberTile": `position: relative; display: flex; width: 100%; height: 34px; padding: 0px; justify-content: center; align-items: center; z-index: 1`, //; margin: 4px 0
    ".eMemberTile div[holder]": `--opacity: 0; position: relative; display: flex; width: 100%; padding: 4px; overflow: hidden; align-items: center; transition: .1s`, //; margin: 4px 0
    ".eMemberBackground": `position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; background: var(--themeColor); opacity: var(--opacity); transition: .1s; z-index: -1`,
    ".eMemberAccessHolder button:hover div[holder]": `--opacity: .35`,
    ".eMemberAccessHolder button:hover .eMemberCursor": `background: var(--themeColor); border-color: var(--pageColor); transform: translateX(-3px) scale(1.15)`,
    ".eMemberAccessHolder button:active": `transform: scale(1) !important`,
    ".eMemberAccessHolder button:active div[holder]": `--opacity: 1; color: var(--hoverTextColor); border-radius: 18px; transform: scale(.95)`,
    ".eMemberAccessHolder button:active .eMemberCursor": `transform: scale(1.15)`,
    ".eMemberTile div[holder][selected]": `--opacity: 1 !important; color: var(--hoverTextColor)`,
    ".eMemberTile div[holder][selected] .eMemberCursor": `background: var(--themeColor); border-color: var(--pageColor)`,
    ".eMemberAccessHolder[hover] div[holder]": `--themeColor: var(--secondary) !important; --opacity: .35 !important; color: var(--textColor)`,
    ".eMemberAccessHolder[hover] .eMemberCursor": `background: var(--themeColor); border-color: var(--pageColor); transform: translateX(-3px) scale(1.15)`,
    ".eMemberAccessHolder[active] div[holder]": `--opacity: 1 !important; border-radius: 18px; transform: scale(.95); color: #fff`,
    ".eMemberAccessHolder[active] .eMemberCursor": `transform: scale(1.15)`,
    ".eMemberAccessHolder[selected] div[holder]": `--themeColor: var(--secondary) !important; --opacity: 1 !important; color: #fff`,
    ".eMemberAccessHolder[selected] .eMemberCursor": `background: var(--themeColor); border-color: var(--pageColor)`,
    ".eMemberCursor": `width: 20px; height: 20px; flex-shrink: 0; margin: 0 6px; background: var(--pageColor); border: solid 3px var(--themeColor); overflow: hidden; border-radius: 8px 14px 14px; transition: 0.2s`, //box-shadow: 0 0 6px rgb(0 0 0 / 50%);
    ".eMemberName": `width: 100%; font-size: 16px; font-weight: 600; text-align: left; text-overflow: ellipsis; white-space: nowrap; overflow: hidden`,
    ".eMemberEvents": `display: flex; margin-left: auto`,
    ".eMemberEvent": `height: fit-content; padding: 3px 6px; margin: 0 1px 0 6px; border-radius: 12px; color: #fff; font-size: 14px; font-weight: 700; white-space: nowrap`,
    ".eMemberEvent[self]": `background: var(--theme)`,
    ".eMemberEvent[hand]": `background: var(--green)`,
    ".eMemberEvent[idle]": `background: var(--yellow)`,
    ".eMemberEvent[observe]": `background: var(--purple)`,

    ".eMemberFrameHolder": `position: absolute; width: 200%; height: fit-content; right: 0px; pointer-events: none; z-index: 0; opacity: 0; transition: top .3s, opacity .3s`,
    ".eMemberFrame": `--themeColor: var(--theme); position: sticky; width: calc(50% - 4px); max-width: calc(100vw - 20px); left: 8px; top: 8px; margin-left: 4px; pointer-events: all; background: var(--pageColor); border-right: solid 4px var(--themeColor); border-radius: 38px 0 0 12px; transform-origin: top right; transform: scale(0); transition: transform .3s`,
    ".eMemberFrameContentHolder": `width: 100%; height: 0px; border-radius: 38px 0 0 12px; overflow: hidden`,
    ".eMemberFrameShadow": `position: absolute; width: 100%; height: 100%; padding: 16px 0 16px 16px; right: 0px; top: -16px; pointer-events: none; border-radius: inherit; overflow: hidden; z-index: -1`,
    ".eMemberFrameShadow:after": `position: absolute; width: calc(100% - 16px); height: calc(100% - 32px); right: 0px; top: 16px; content: ""; box-shadow: var(--shadow); border-radius: inherit`,
    ".eMemberFrameContent": `overflow: auto`,
    ".eMemberSection": `position: relative; display: flex; width: 100%; justify-content: center; align-items: center`,
    ".eMemberSectionInfo": `border-radius: 38px 0 0 38px; overflow: hidden`,
    ".eMemberBackdrop": `position: absolute; display: flex; width: calc(100% + 2px); height: 100%; left: 0px; top: 0px; justify-content: center; align-items: center; background: var(--themeColor); transition: .2s; z-index: -1`,
    ".eMemberBackdrop div": `width: 100%; height: 100%; flex-shrink: 0; opacity: .3; background-image: url(./images/editor/background.svg); background-position: center`, //transform: rotate(12deg);
    ".eMemberFrameCursor": `width: 40px; height: 40px; flex-shrink: 0; margin: 12px; background: var(--themeColor); border: solid 6px var(--pageColor); border-radius: 16px 28px 28px; transition: 0.2s`,
    ".eMemberFramePicture": `width: 44px; height: 44px; flex-shrink: 0; margin: 12px; border: solid 4px var(--pageColor); object-fit: cover; border-radius: 28px; transition: 0.2s`,
    ".eMemberFrameInfoHolder": `display: flex; flex-direction: column; width: calc(100% - 76px); height: calc(100% - 12px); color: var(--adaptColor); text-align: left`,
    ".eMemberFrameInfoHolder div[name]": `width: calc(100% - 30px); font-size: 20px; font-weight: 700; text-overflow: ellipsis; white-space: nowrap; overflow: hidden`,
    ".eMemberFrameInfoHolder div[email]": `width: 100%; font-size: 15px; font-weight: 500; margin-top: 3px; text-overflow: ellipsis; white-space: nowrap; overflow: hidden`,
    ".eMemberFrameInfoHolder div[joined]": `font-size: 14px; font-weight: 500; text-align: right; margin: auto 6px 2px 0; text-overflow: ellipsis; white-space: nowrap; overflow: hidden`,
    ".eMemberClose": `position: absolute; width: 22px; height: 22px; top: 4px; right: 0px; margin: 5px 5px 5px 12px; background: var(--pageColor); --borderWidth: 3px; --borderRadius: 14px`,
    ".eMemberClose img": `position: absolute; width: calc(100% - 10px); height: calc(100% - 10px); left: 5px; top: 5px`,
    ".eMemberSectionDesc": `box-sizing: border-box; padding: 12px 12px 0; font-size: 14px`,
    ".eMemberSectionEvents": `flex-direction: column`,
    ".eMemberEventHolder": `display: none; width: calc(100% - 24px); margin: 12px 12px 0px; justify-content: space-between; align-items: center`,
    ".eMemberEventHolder .eMemberEvent": `margin: 0px 8px 0 0`,
    ".eMemberEventDesc": `font-size: 14px; text-align: right`,
    ".eMemberSectionActions": `flex-wrap: wrap; width: calc(100% - 12px); padding: 6px; margin-top: 6px; justify-content: space-around`,
    ".eMemberSectionActions button": `display: flex; flex-direction: column; width: 86.33px; padding: 6px 12px; align-items: center; border-radius: 14px; color: var(--themeColor); overflow: visible`,
    ".eMemberSectionActions button img": `width: 55px; height: 55px; transition: .15s`,
    ".eMemberSectionActions button div": `margin-top: 6px; font-size: 14px; font-weight: 600; white-space: nowrap`,
    ".eMemberSectionActions button:hover img": `transform: scale(1.15) translateY(-2px)`,
    ".eMemberSectionActions button:active": `background: var(--themeColor); color: #fff`,
    ".eMemberSectionActions button:active img": `filter: brightness(0) invert(1); transform: scale(1)`
  };
  js = async function (frame, extra) {
    let editor = await findModule(extra.origin);

    frame.closest(".dropdownContent").style.padding = "0px";

    let searchField = frame.querySelector(".eMemberSearchHolder input");
    let accessHolders = frame.querySelectorAll(".eMemberAccessHolder");

    let getSection = (access) => {
      /*
      let sectionType = "viewer";
      if (access > 4) {
        sectionType = "owner";
      } else if (access > 0) {
        sectionType = "editor";
      }
      return frame.querySelector('.eMemberAccessHolder[type="' + sectionType + '"]');
      */
      return frame.querySelector('.eMemberAccessHolder[access="' + access + '"]');
    }
    let updateOrder = (section, updateTile, member) => {
      for (let i = 1; i < section.children.length; i++) { // 1 to skip title
        let child = section.children[i];
        let prev = editor.members[child.querySelector("div[holder]").getAttribute("member")] ?? {};
        if (member.hand == null) {
          if (child != updateTile && member.name < prev.name && prev.hand == null) {
            section.insertBefore(updateTile, child);
            break;
          } else if (i == section.children.length - 1) {
            section.appendChild(updateTile);
          }
        } else {
          if (child != updateTile && (member.hand < prev.hand || prev.hand == null)) {
            section.insertBefore(updateTile, child);
            break;
          } else if (i == section.children.length - 1) {
            section.appendChild(updateTile);
          }
        }
      }
    }
    let addMemberTile = (member) => {
      if (member.name.toLowerCase().includes(searchField.value.toLowerCase()) == false) {
        return;
      }
      let section = getSection(member.access);
      if (section == null) {
        return;
      }
      let title = section.querySelector(".eMemberAccessTitle");
      section.insertAdjacentHTML("beforeend", `<button class="eMemberTile"><div holder new>
        <div class="eMemberBackground"></div>
        <div class="eMemberCursor"></div>
        <div class="eMemberName"></div>
        <div class="eMemberEvents"></div>
      </div></button>`);
      let tile = section.querySelector(".eMemberTile div[holder][new]");
      tile.removeAttribute("new");
      tile.setAttribute("member", member._id);
      updateOrder(section, tile.parentElement, member);
      tile.style.setProperty("--themeColor", member.color);
      tile.style.setProperty("--hoverTextColor", editor.textColorBackground(member.color));
      tile.querySelector(".eMemberName").textContent = member.name;
      tile.querySelector(".eMemberName").title = member.name;
      let eventsHolder = tile.querySelector(".eMemberEvents");
      if (member._id == editor.sessionID) {
        eventsHolder.insertAdjacentHTML("afterbegin", `<div class="eMemberEvent" self title="This member is you.">YOU</div>`);
      } else { // Don't show if self:
        if (member.active == false) {
          eventsHolder.insertAdjacentHTML("afterbegin", `<div class="eMemberEvent" idle title="This member is currently viewing a different window.">IDLE</div>`);
        }
        if (member.observe == editor.sessionID) {
          eventsHolder.insertAdjacentHTML("afterbegin", `<div class="eMemberEvent" observe title="This member is observing you on the document.">OBSERVE</div>`);
        }
      }
      if (member.hand != null) {
        eventsHolder.insertAdjacentHTML("afterbegin", `<div class="eMemberEvent" hand title="This member is asking to contribute to the lesson.">HAND</div>`);
      }
      title.querySelector("div[count]").textContent = section.childElementCount - 1; // -1 for title
      section.style.display = "block";
    }
    let createMemberList = (search) => {
      let keys = Object.keys(editor.members);
      keys = keys.filter((value) => {
        if (editor.members[value].name.toLowerCase().includes((search ?? "").toLowerCase())) {
          return -1;
        }
        return false;
      });
      for (let i = 0; i < keys.length; i++) {
        addMemberTile(editor.members[keys[i]]);
      }
    }
    createMemberList();

    let dropdown;
    let memberFrameHolder;
    let dropdownButton;

    editor.updateMembersList = (data) => {
      let body = data.data;
      let member = editor.members[body._id];

      switch (data.task) {
        case "join":
          addMemberTile(member);
          break;
        case "leave":
          let removeTileContent = frame.querySelector('.eMemberTile div[holder][member="' + body._id + '"]');
          if (removeTileContent != null) {
            let removeTile = removeTileContent.parentElement;
            let title = removeTile.parentElement.querySelector("div[count]");
            let newCount = removeTile.parentElement.childElementCount - 2; // -2 for title and tile
            title.textContent = newCount;
            if (newCount < 1) {
              removeTile.parentElement.style.display = "none";
            }
            if ((dropdownButton != null && dropdownButton.getAttribute("member") == body._id) || (newCount < 1 && removeTile.parentElement.hasAttribute("selected"))) {
              closeDropdown();
            }
            removeTile.remove();
          }
          break;
        case "update":
          let updateTile = frame.querySelector('.eMemberTile div[holder][member="' + body._id + '"]');
          if (updateTile != null) {
            // Handle User / Color Updates:
            updateTile.style.setProperty("--themeColor", member.color);
            updateTile.querySelector(".eMemberName").textContent = member.name;
            updateTile.querySelector(".eMemberName").title = member.name;

            // Handle access changes:
            let section = getSection(member.access);
            let oldSection = updateTile.parentElement.parentElement;
            if (section != oldSection) {
              section.appendChild(updateTile.parentElement);
              /*
              for (let i = 1; i < section.children.length; i++) { // 1 to skip title
                let child = section.children[i];
                if (parseInt(child.getAttribute("joined")) < member.joined) {
                  section.insertBefore(updateTile, child);
                  break;
                }
              }
              */
              // Update new section:
              section.querySelector(".eMemberAccessTitle div[count]").textContent = section.childElementCount - 1; // -1 for title
              section.style.display = "block";
              // Update old section:
              let newOldCount = oldSection.childElementCount - 1; // -1 for title
              oldSection.querySelector(".eMemberAccessTitle div[count]").textContent = newOldCount;
              if (newOldCount < 1) {
                oldSection.style.display = "none";
              }
            }

            // Update order:
            updateOrder(section, updateTile.parentElement, member);

            // Handle event state:
            if (member._id != editor.sessionID) {
              let eventsHolder = updateTile.querySelector(".eMemberEvents");
              let existingHand = eventsHolder.querySelector(".eMemberEvent[hand]");
              if (member.hand != null) {
                if (existingHand == null) {
                  eventsHolder.insertAdjacentHTML("afterbegin", `<div class="eMemberEvent" hand title="This member is asking to contribute to the lesson.">HAND</div>`);
                }
              } else if (existingHand != null) {
                existingHand.remove();
              }
              let existingIdle = eventsHolder.querySelector(".eMemberEvent[idle]");
              if (member.active == false) {
                if (existingIdle == null) {
                  eventsHolder.insertAdjacentHTML("afterbegin", `<div class="eMemberEvent" idle title="This member is currently viewing a different window.">IDLE</div>`);
                }
              } else if (existingIdle != null) {
                existingIdle.remove();
              }
              let existingObserve = eventsHolder.querySelector(".eMemberEvent[observe]");
              if (member.observe == editor.sessionID) {
                if (existingObserve == null) {
                  eventsHolder.insertAdjacentHTML("afterbegin", `<div class="eMemberEvent" observe title="This member is observing you on the document.">OBSERVE</div>`);
                }
              } else if (existingObserve != null) {
                existingObserve.remove();
              }
            }
            //if (top == true) {
            //  section.insertBefore(tile, section.children[1]);
            //}

            // Update member dropdown:
            if (dropdownButton != null) {
              if (dropdownButton.getAttribute("member") == member._id) {
                openDropdown(updateTile, true);
              } else if (dropdownButton.querySelector("div[title]") != null) {
                openDropdown(dropdownButton, true);
              }
            }
          }
      }
    }

    let updateDropdownPosition = () => {
      if (memberFrameHolder == null) {
        return;
      }
      if (dropdownButton == null) {
        dropdown.style.borderTopLeftRadius = "12px";
        dropdown.style.borderBottomLeftRadius = "12px";
        return;
      }
      let dropdownRect = dropdown.getBoundingClientRect();
      let buttonRect = dropdownButton.closest("button").getBoundingClientRect();
      
      let contentFrame = memberFrameHolder.querySelector(".eMemberFrame");
      let contentHolderFrameHolder = contentFrame.querySelector(".eMemberFrameContentHolder");
      let contentFrameHolder = contentFrame.querySelector(".eMemberFrameContent");
      
      let contentHeight = contentFrameHolder.scrollHeight;
      //contentFrame.style.maxHeight = Math.min(fixed.offsetHeight - dropdownRect.top, contentHeight + 8) - 8 + "px";

      contentFrameHolder.style.maxHeight = fixed.offsetHeight - dropdownRect.top - 8 + "px";
      
      contentHolderFrameHolder.style.height = contentFrameHolder.offsetHeight + "px";
      contentHolderFrameHolder.offsetHeight;
      contentHolderFrameHolder.style.transition = "height .3s";

      let setTop = buttonRect.top - dropdownRect.top;
      if (buttonRect.top < dropdownRect.top) {
        setTop = 0;
      }
      if (setTop < dropdownRect.top) { // Above dropdown:
        setTop = 0;
      }
      if (buttonRect.top + contentHeight > fixed.offsetHeight - dropdownRect.top - 8) { // Below dropdown:
        setTop = fixed.offsetHeight - contentFrameHolder.offsetHeight - dropdownRect.top - 8;
      }
      memberFrameHolder.style.top = setTop + "px";
      
      if (setTop < dropdownRect.top) { // Top border radius:
        dropdown.style.borderTopLeftRadius = "0px";
      } else {
        dropdown.style.borderTopLeftRadius = "12px";
      }
      if (setTop + contentFrameHolder.offsetHeight > dropdownRect.top + dropdown.offsetHeight - 20) { // Bottom border radius:
        dropdown.style.borderBottomLeftRadius = "0px";
      } else {
        dropdown.style.borderBottomLeftRadius = "12px";
      }
    }
    window.removeEventListener("resize", updateDropdownPosition); // Prevent duplicates
    tempListen(window, "resize", updateDropdownPosition);
    frame.closest(".dropdownContent").addEventListener("scroll", updateDropdownPosition);
    let closeDropdown = async () => {
      if (memberFrameHolder == null) {
        return;
      }
      if (dropdownButton != null) {
        dropdownButton.removeAttribute("selected");
        if (dropdownButton.parentElement != null) {
          dropdownButton.parentElement.removeAttribute("selected");
        }
        dropdownButton = null;
      }
      memberFrameHolder.style.opacity = 0;
      let frame = memberFrameHolder.querySelector(".eMemberFrame");
      frame.querySelector(".eMemberFrameContentHolder").style.removeProperty("transition");
      frame.style.width = frame.clientWidth + "px";
      frame.style.transform = "scale(0)";
      updateDropdownPosition();
    }
    window.closeDropdown = closeDropdown;

    let editorButton;
    let handButton;
    let observeButton;
    let spotlightButton;
    let kickButton;
    
    let openDropdown = (tile, update) => {
      let member = {};
      if (tile.parentElement.className == "eMemberTile") {
        member = editor.members[tile.getAttribute("member")];
        if (member == null) {
          tile.remove();
          return;
        }
      } else {
        member = { title: true, name: tile.querySelector("div[title]").textContent, access: parseInt(tile.closest(".eMemberAccessHolder").getAttribute("access")), color: "var(--secondary)" };
      }
      if (dropdownButton != null) {
        if (dropdownButton == tile && update != true) {
          closeDropdown();
          return;
        } else {
          dropdownButton.removeAttribute("selected");
          if (dropdownButton.parentElement != null) {
            dropdownButton.parentElement.removeAttribute("selected");
          }
        }
      }
      dropdownButton = tile;
      if (member.title == null) {
        dropdownButton.setAttribute("selected", "");
      } else {
        dropdownButton.parentElement.setAttribute("selected", "");
      }
      dropdown = frame.closest(".dropdown");
      memberFrameHolder = dropdown.querySelector(".eMemberFrameHolder");
      editor.realtime.module.observeButtonUpdate = () => {
        let memberFrame = memberFrameHolder.querySelector(".eMemberFrame");
        let button = memberFrame.querySelector(".eMemberSectionActions button[observe]");
        let member = editor.members[memberFrame.getAttribute("memberid")];
        if (member == null) {
          return;
        }
        let obvImg = "./images/editor/members/observe.svg";
        let obvText = "Observe";
        let obvDesc = "Watch this member's screen.";
        if (editor.realtime.observing == member._id) {
          obvImg = "./images/editor/members/observeexit.svg";
          obvText = "Exit";
          obvDesc = "Stop watching this member's screen."
        }
        button.querySelector("img").src = obvImg;
        button.querySelector("div").textContent = obvText;
        button.title = obvDesc;
        if (member.weak != true && editor.realtime.strength > 2 && member.observe == null) {
          observeButton.style.opacity = 1;
        } else {
          observeButton.style.opacity = .5;
        }
      }
      editor.realtime.module.checkSpotlightUpdate = (fromSelf) => {
        let member = editor.members[memberFrame.getAttribute("memberid")] ?? {};
        let wasShown = spotlightButton.hasAttribute("shown");
        if (member._id == editor.sessionID && member.access > 3 && editor.memberCount > 1) {
          spotlightButton.style.display = "flex";
          if (fromSelf != true && wasShown == false) {
            spotlightButton.setAttribute("shown", "");
            updateDropdownPosition();
          }
        } else {
          spotlightButton.style.display = "none";
          if (fromSelf != true && wasShown == true) {
            spotlightButton.removeAttribute("shown");
            updateDropdownPosition();
          }
        }
        if (editor.realtime.strength > 2) {
          spotlightButton.style.opacity = 1;
        } else {
          spotlightButton.style.opacity = .5;
        }
      }
      if (memberFrameHolder == null) {
        dropdown.insertAdjacentHTML("beforeend", `<div class="eMemberFrameHolder">
        <div class="eMemberFrame">
          <div class="eMemberFrameShadow"></div>
          <div class="eMemberFrameContentHolder">
            <div class="eMemberFrameContent">
              <div class="eMemberSection eMemberSectionInfo">
                <div class="eMemberBackdrop"><div></div></div>
                <div class="eMemberFrameCursor"></div>
                <img class="eMemberFramePicture">
                <div class="eMemberFrameInfoHolder">
                  <div name></div>
                  <div email></div>
                </div>
                <button class="eMemberClose buttonAnim border"><img src="./images/tooltips/close.svg"></button>
              </div>
              <div class="eMemberSection eMemberSectionDesc"></div>
              <div class="eMemberSection eMemberSectionEvents">
                <div class="eMemberEventHolder" self>
                  <div class="eMemberEvent" self>YOU</div>
                  <div class="eMemberEventDesc">This is your profile.</div>
                </div>
                <div class="eMemberEventHolder" hand>
                  <div class="eMemberEvent" hand>HAND</div>
                  <div class="eMemberEventDesc">They're asking to contribute to the lesson.</div>
                </div>
                <div class="eMemberEventHolder" idle>
                  <div class="eMemberEvent" idle>IDLE</div>
                  <div class="eMemberEventDesc">They're currently viewing another window.</div>
                </div>
                <div class="eMemberEventHolder" observe>
                  <div class="eMemberEvent" observe>OBSERVE</div>
                  <div class="eMemberEventDesc">They're following you around the lesson.</div>
                </div>
              </div>
              <div class="eMemberSection eMemberSectionActions">
                <button editor style="--themeColor: var(--theme)">
                  <img>
                  <div></div>
                </button>
                <button hand style="--themeColor: var(--green)" title="Lower this member's hand.">
                  <img src="./images/editor/members/lowerhand.svg">
                  <div>Lower</div>
                </button>
                <button observe style="--themeColor: var(--purple)">
                  <img>
                  <div>Observe</div>
                </button>
                <button spotlight style="--themeColor: var(--purple)" title="Bring members to your location.">
                  <img src="./images/editor/members/spotlight.svg">
                  <div>Spotlight</div>
                </button>
                <button kick style="--themeColor: var(--error)" title="Revoke all viewing and editing privileges.">
                  <img src="./images/editor/members/kick.svg">
                  <div>Kick</div>
                </button>
              </div>
            </div>
          </div>
        </div></div>`);
        memberFrameHolder = dropdown.querySelector(".eMemberFrameHolder");
        memberFrameHolder.querySelector(".eMemberClose").addEventListener("click", closeDropdown);
        memberFrameHolder.offsetHeight;

        editorButton = memberFrameHolder.querySelector(".eMemberSectionActions button[editor]");
        handButton = memberFrameHolder.querySelector(".eMemberSectionActions button[hand]");
        observeButton = memberFrameHolder.querySelector(".eMemberSectionActions button[observe]");
        spotlightButton = memberFrameHolder.querySelector(".eMemberSectionActions button[spotlight]");
        kickButton = memberFrameHolder.querySelector(".eMemberSectionActions button[kick]");
        editorButton.addEventListener("click", async (event) => {
          editorButton.setAttribute("disabled", "");
          let frame = event.target.closest(".eMemberFrame");
          let memberid = frame.getAttribute("memberid");
          let frameAccess = frame.getAttribute("access");
          let url = "lessons/members/access";
          let sendAccess = 1;
          if (memberid != null) {
            let member = editor.members[memberid];
            if (member.access == 1) {
              sendAccess = 0;
            }
            url += "?member=" + member._id;
          } else if (frameAccess != null) {
            url += "?permaccess=" + frameAccess;
            if (parseInt(frameAccess) == 1) {
              sendAccess = 0;
            }
          }
          let [code] = await sendRequest("PUT", url, { access: sendAccess }, { session: editor.session });
          if (code == 200) {
            if (frameAccess != null) {
              getSection(frameAccess).style.display = "none";
              let changeSection = getSection(sendAccess);
              changeSection.style.display = "block";
              openDropdown(changeSection.querySelector(".eMemberAccessTitle"));
            }
          } /* else if (code == 404 || code == 500) {
            if (memberid != null) {
              if (editor.members[body._id]) {
                if (editor.members[body._id].access == 1) {
                  editor.editorCount--;
                }
                editor.checkEditorCount();
                delete editor.members[memberid];
              }
              editor.realtime.module.removeRealtime(memberid);
              editor.updateMemberCount();
            }
          } */
          editorButton.removeAttribute("disabled");
        });
        handButton.addEventListener("click", async (event) => {
          handButton.setAttribute("disabled", "");
          let frame = event.target.closest(".eMemberFrame");
          let memberid = frame.getAttribute("memberid");
          let url = "lessons/members/hand/lower";
          if (memberid != null) {
            url += "?member=" + memberid;
          } else {
            url += "?member=all";
          }
          await sendRequest("DELETE", url, null, { session: editor.session });
          /*
          if (code == 200) {
            if (frameAccess != null) {
              getSection(frameAccess).style.display = "none";
              let changeSection = getSection(sendAccess);
              changeSection.style.display = "block";
              openDropdown();
            }
          }
          */
          handButton.removeAttribute("disabled");
        });
        observeButton.addEventListener("click", async (event) => {
          let memberid = event.target.closest(".eMemberFrame").getAttribute("memberid");
          if (editor.realtime.observing == memberid) {
            editor.realtime.module.exitObserve();
            return;
          }
          let member = editor.members[memberid];
          if (member == null) {
            (await loadModule("dropdown")).close();
            return;
          }
          let alertModule = await loadModule("alert");
          if (editor.realtime.strength < 3) {
            alertModule.open("error", `<b>Unable to Connect</b>Your connection is too weak to watch their screen.`);
            return;
          }
          if (member.observe != null) {
            alertModule.open("error", `<b>Unable to Connect</b>This member is observing someone else.`);
            return;
          }
          if (member.weak == true) {
            alertModule.open("error", `<b>Unable to Connect</b>${member.name} has too weak of a connection to watch their screen.`);
            return;
          }
          observeButton.setAttribute("disabled", "");
          let prevObserve = editor.realtime.observing;
          editor.realtime.observing = memberid;
          editor.realtime.module.setShortSub(editor.visibleChunks);
          editor.realtime.module.observeButtonUpdate();
          alertModule.close(editor.realtime.observeLoading);
          clearTimeout(editor.realtime.observeTimeout);
          let [code] = await sendRequest("GET", "lessons/members/observe?member=" + memberid, null, { session: editor.session });
          if (code == 200) {
            editor.realtime.observeLoading = await alertModule.open("info", `<b>Connecting to Member</b>Connecting to ${member.name}'s screen to observe!`, { time: "never" });
            editor.realtime.observeTimeout = setTimeout(() => {
              alertModule.close(editor.realtime.observeLoading);
              alertModule.open("error", `<b>Observe Timeout</b>Failed to connect to their screen, please try again later...`);
              editor.realtime.module.exitObserve();
            }, 10000);
          } else {
            if (prevObserve != null) {
              editor.realtime.observing = prevObserve;
              editor.realtime.module.exitObserve();
            }
            editor.realtime.observing = null;
            editor.realtime.module.setShortSub(editor.visibleChunks);
            editor.realtime.module.observeButtonUpdate();
          }
          observeButton.removeAttribute("disabled");
        });
        spotlightButton.addEventListener("click", async (event) => {
          let memberid = event.target.closest(".eMemberFrame").getAttribute("memberid");
          let member = editor.members[memberid];
          if (member == null) {
            (await loadModule("dropdown")).close();
            return;
          }
          let alertModule = await loadModule("alert");
          if (editor.realtime.strength < 3) {
            alertModule.open("error", `<b>Unable to Connect</b>Your connection is too weak to use spotlight.`);
            return;
          }
          if (editor.realtime.observing != null) {
            editor.realtime.module.exitObserve();
          }
          spotlightButton.setAttribute("disabled", "");
          alertModule.open("info", `<b>Spotlight</b>Letting members know about the spotlight...`);
          await sendRequest("GET", "lessons/members/observe/spotlight?member=" + memberid, null, { session: editor.session });
          spotlightButton.removeAttribute("disabled");
        });
        kickButton.addEventListener("click", async (event) => {
          kickButton.setAttribute("disabled", "");
          let frame = event.target.closest(".eMemberFrame");
          let memberid = frame.getAttribute("memberid");
          let url = "lessons/members/kick";
          if (memberid != null) {
            url += "?member=" + editor.members[memberid]._id;
          } else {
            url += "?permaccess=" + frame.getAttribute("access");
          }
          let [code] = await sendRequest("DELETE", url, null, { session: editor.session });
          if (code == 200) {
            closeDropdown();
          }
          kickButton.removeAttribute("disabled");
        });
      }
      let memberFrame = memberFrameHolder.querySelector(".eMemberFrame");
      if (member.title == null) {
        memberFrame.setAttribute("memberid", member._id);
        memberFrame.removeAttribute("access");
        memberFrame.style.setProperty("--adaptColor", editor.textColorBackground(member.color));
      } else {
        memberFrame.setAttribute("access", member.access);
        memberFrame.removeAttribute("memberid");
        memberFrame.style.setProperty("--adaptColor", "#fff");
      }
      memberFrame.style.setProperty("--themeColor", member.color);
      memberFrame.style.removeProperty("width");
      let cursor = memberFrameHolder.querySelector(".eMemberFrameCursor");
      let picture = memberFrameHolder.querySelector(".eMemberFramePicture");
      if (member.image == null) {
        picture.style.display = "none";
        cursor.style.display = "unset";
      } else {
        cursor.style.display = "none";
        picture.src = member.image;
        picture.style.display = "unset";
      }
      let name = memberFrameHolder.querySelector(".eMemberFrameInfoHolder div[name]");
      name.textContent = member.name;
      name.title = member.name;
      let email = memberFrameHolder.querySelector(".eMemberFrameInfoHolder div[email]");
      if (member.email) {
        email.textContent = member.email;
        email.title = member.email;
        email.style.display = "unset";
      } else {
        email.style.display = "none";
      }
      let frameDesc = memberFrameHolder.querySelector(".eMemberSectionDesc");
      if (member.title) {
        switch (member.access) {
          case 0:
            frameDesc.textContent = "Viewers can see all pages and annotations in this lesson.";
            break;
          case 1:
            frameDesc.textContent = "Editors can create annotation, but cannot grant permisions or change settings.";
            break;
          case 5:
            frameDesc.textContent = "The owner has full access to all aspects of the lesson.";
        }
        frameDesc.style.display = "block";
      } else {
        frameDesc.style.display = "none";
      }
      let isSelf = member._id == editor.sessionID;
      let self = memberFrameHolder.querySelector(".eMemberEventHolder[self]");
      let hand = memberFrameHolder.querySelector(".eMemberEventHolder[hand]");
      let idle = memberFrameHolder.querySelector(".eMemberEventHolder[idle]");
      let observe = memberFrameHolder.querySelector(".eMemberEventHolder[observe]");
      if (isSelf) {
        self.style.display = "flex";
      } else {
        self.style.display = "none";
      }
      if (member.hand != null) {
        hand.style.display = "flex";
      } else {
        hand.style.display = "none";
      }
      if (member.active == false && !isSelf) {
        idle.style.display = "flex";
      } else {
        idle.style.display = "none";
      }
      if (member.observe == editor.sessionID && !isSelf) {
        observe.style.display = "flex";
      } else {
        observe.style.display = "none";
      }
      editorButton.removeAttribute("disabled");
      handButton.removeAttribute("disabled");
      observeButton.removeAttribute("disabled");
      kickButton.removeAttribute("disabled");
      let myself = editor.getSelf();
      if (!isSelf && myself.access > 2 && member.access < 2) {
        let image = "./images/editor/share/editor.svg";
        let text = "Editor";
        let desc = "Grant temporary editing privileges.";
        if (member.access == 1) {
          image = "./images/editor/share/viewer.svg";
          text = "Viewer";
          desc = "Revoke temporary editing privileges, granting viewer.";
        }
        editorButton.querySelector("img").src = image;
        editorButton.querySelector("div").textContent = text;
        editorButton.title = desc;
        editorButton.style.display = "flex";
      } else {
        editorButton.style.display = "none";
      }
      let handRaised = member.hand != null;
      if (member.title != null) {
        // If someone in section has hand raised
        handRaised = tile.parentElement.querySelector(".eMemberEvent[hand]") != null;
      }
      if (!isSelf && myself.access > 3 && handRaised) {
        handButton.style.display = "flex";
      } else {
        handButton.style.display = "none";
      }
      if (!isSelf && myself.access > 3 && member.access < 4) {
        kickButton.style.display = "flex";
      } else {
        kickButton.style.display = "none";
      }
      editor.realtime.module.observeButtonUpdate();
      if (!isSelf && member.title == null && (member.access > 0 || editor.lesson.settings.observeViewers != false || myself.access > 3)) {
        observeButton.style.display = "flex";
      } else {
        observeButton.style.display = "none";
      }
      editor.realtime.module.checkSpotlightUpdate(true);
      memberFrameHolder.style.opacity = 1;
      memberFrame.style.transform = "scale(1)";
      updateDropdownPosition();
    }
    frame.addEventListener("click", async function (event) {
      let element = event.target;
      if (element == null) {
        return;
      }
      let memberTile = element.closest(".eMemberTile") ?? element.closest(".eMemberAccessTitle");
      if (memberTile) {
        if (memberTile.className == "eMemberTile") {
          memberTile = memberTile.querySelector("div[holder]");
        }
        openDropdown(memberTile);
        return;
      }
    });

    /*
    let updateHolders = () => {
      for (let i = 0; i < accessHolders.length; i++) {
        let holder = accessHolders[i];
        if (holder.childElementCount < 2) { // Have 1 for title

        }
      }
    }
    */

    for (let i = 0; i < accessHolders.length; i++) {
      let holder = accessHolders[i];
      let title = holder.querySelector(".eMemberAccessTitle");
      title.addEventListener("mouseenter", function() {
        holder.setAttribute("hover", "");
      });
      title.addEventListener("mouseleave", function() {
        holder.removeAttribute("hover");
        holder.removeAttribute("active");
      });
      title.addEventListener("mousedown", function() {
        holder.setAttribute("active", "");
      });
      title.addEventListener("mouseup", function() {
        holder.removeAttribute("active");
      });
    }
    
    searchField.addEventListener("input", () => {
      closeDropdown();
      
      let clearTiles = frame.querySelectorAll(".eMemberTile");
      for (let i = 0; i < clearTiles.length; i++) {
        if (clearTiles[i].parentElement.childElementCount < 3) { // 3 to account for title and removed tile
          clearTiles[i].parentElement.style.display = "none";
        }
        clearTiles[i].remove();
      }

      createMemberList(searchField.value);
    });
    /*
    (async function () {
      await sleep(400);
      searchField.focus();
    })();
    */
  }
}
modules["dropdowns/editor/share"] = class {
  html = `
  <button class="eShareOption" dropdown="dropdowns/editor/share/pin" dropdowntitle="<div>Present with <b style='color: var(--theme); font-weight: 800'>Pin</b></div>" title="Invite members through a pin."><img src="./images/editor/share/pin.svg"><div class="eShareInfo"><div class="eShareTitle">Present with <b>Pin</b></div><div class="eShareDesc">Allow members to join as a viewer through a 6-digit pin code.</div></div></button>
  <button class="eShareOption" dropdown="dropdowns/editor/share/link" dropdowntitle="<div>Share with <b style='color: var(--theme); font-weight: 800'>Link</b></div>" title="Invite members through a link."><img src="./images/editor/share/link.svg"><div class="eShareInfo"><div class="eShareTitle">Share with <b>Link</b></div><div class="eShareDesc">Allow members to join as a viewer or editor through a sendable link.</div></div></button>
  <button class="eShareOption" dropdown="dropdowns/editor/share/email" dropdowntitle="<div>Invite with <b style='color: var(--theme); font-weight: 800'>Email</b></div>" title="Invite members through email."><img src="./images/editor/share/email.svg"><div class="eShareInfo"><div class="eShareTitle">Invite with <b>Email</b></div><div class="eShareDesc">Invite members as a viewer or editor with their email.</div></div></button>
  `;
  css = {
    ".eShareOption": `display: flex; flex-wrap: wrap; min-width: 100%; padding: 0; border-radius: 8px; align-items: center; transition: .15s`,
    ".eShareOption:not(:first-child)": `margin-top: 6px`,
    ".eShareOption:hover": `background: var(--theme); color: #fff`,
    ".eShareOption:hover img": `filter: brightness(0) invert(1)`,
    ".eShareOption:hover b": `color: #fff`,
    ".eShareOption:active": `transform: scale(.95); border-radius: 14px`,
    ".eShareOption img": `height: 32px; margin: 6px; transition: .15s`,
    ".eShareOption .eShareInfo": `margin: 6px; text-align: left`,
    ".eShareOption .eShareTitle": `margin-right: 6px; font-size: 18px; font-weight: 600`,
    ".eShareOption b": `color: var(--theme); font-weight: 800; transition: .15s`,
    ".eShareOption .eShareDesc": `max-width: 250px; font-size: 14px`
  };
  js = async function () {
    /*
    let editor = await findModule(extra.origin);
    if (editor.getSelf().access < 2) {
      frame.querySelector(`.eShareOption[dropdown="dropdowns/editor/share/link"]`).remove();
      let shareDesc = frame.querySelectorAll(".eShareDesc");
      for (let i = 0; i < shareDesc.length; i++) {
        shareDesc[i].remove();
      }
    }
    */
  }
}